# 年齢当て問題の関数化

## 関数化とは？

プログラムの関数化は、コードを小さな部品に分割し、それぞれの部品が特定の処理を実行できるようにすることです。関数化はコードの再利用性のしやすさ、プログラムの管理のしやすさ、理解しやすさを向上させることができます。

実際に年齢あて問題をプログラムで実装して、それを関数化してみましょう！


## 年齢あて問題の実装アルゴリズム

まず年齢を当てるアルゴリズム（計算手順）を考えてみましょう！ここでは最高年齢は100歳までとします。

様々な方法がありますが、最も簡単に考えられるのは**0歳から100歳までを順番に聞いていく**方法です。このような方法を**全探索**といいます。しかし、この方法だと毎回年齢を当てたい人に質問する必要があるため、時間もかかるし、質問する人も疲れてしまいますよね.......

そこで！今回は**二分探索**という方法で問題を解いてみようと思います！簡単に説明すると、二分探索は「二つに分けて探す」という考え方を使います。

例えば、**1から10**までの数字が順番に並んでいるとき、**7**を探したいとしましょう。この場合、1から10までの数字を**2**つのグループに分けます。**1から5まで**と**6から10まで**です。7は6から10までの中にあるので、6から10の中で、もう一度二分探索を行います。

6から10を二つのグループに分けると、**6から8まで**と**9から10まで**に分けられます。7は6から8までの中にあるので6から8の間でもう一度二分探索を行います。

6から8を二つのグループに分けると、**6,7**と**8**に分けられます。7は6,7のグループにあるのでここから7を探します。

このようにして値を求めていくと探さなければならない範囲が処理をするごとに半分になっていることがわかると思います！！

したがって、二分探索を用いることで、全探索と比べて質問する回数が減り、より早く、質問者もあまり疲れずに年齢を当てることができます！

## 年齢あて問題の実装プログラム
それでは早速コードを実装していきます。まずは**関数化**を行わずに記述していきます！
もとめる年齢は0歳から100歳までで、小さい順に年齢が並んでいるとします!

```python
#当てる年齢の範囲の右端と左端の値を取得(今回は0歳から100歳まで)
left = 0
right = 100
#求める年齢を取得(ここでは19歳)
age = 19
#処理状態の表示の有無
display = True
#繰り返し回数を保持
count = 0
#初めの状態を表示
if display:#displayにはTrueかFalseが入っているからこれだけでOK
    print(f'繰り返し前です。')
    print(f" 左端は{left}です。右端は{right}です。")
#右端の値が左端の値以上になるまで繰り返す
while right >= left:
    count += 1#繰り返しごとに1を足し合わせる。
    #leftとrightの真ん中の値を取得
    mid = left + (right - left) // 2#小数点切り捨て　年齢で小数は考えたくないよね
    #もしageがmidならそれが答えなので繰り返しをやめる
    if age == mid:
        break
    #もしageがmid未満なら右端(right)をmid - 1にする (midは求める値の範囲に入らない！)
    elif age < mid:
        right = mid -1
    #もしageがmidより大きいなら左端(left)をmid + 1にする　(midは求める値の範囲に入らない！)
    elif age > mid:
        left = mid + 1
    #もし処理状態の表示が有なら表示する
    if display:
        print(f'現在{count}回目の繰り返しです。')
        print(f" 左端は{left}です。右端は{right}です。真ん中は{mid}です。")
#最終的にmidが答えになる
print(f"答えは{mid}歳です！！")
```
いかがでしょうか？実際にコピペして動くか試してみてください！そのあと変数の値をいろいろ変えて試してみてください！

....いや、変数変えて試すの結構めんどくさいな..

試しているうちにこんな考えになってくると思います。そこで！変数の値を**自由**に、**簡単に**変えられれば便利になると思いませんか?

そこで今回の本題の関数化をしていくわけです。

## プログラムの関数化
先ほど作成したプログラムを簡単に調整できるようにプログラムの**関数化**をしていきます。変更点としては関数の引数に先ほどのプログラムのleft,right,count,age,displayを引数にして渡す処理に修正していきます。

```python
def guess_age(left,right,age,display=False):
    count = 0
    #初めの状態を表示
    if display:#displayにはTrueかFalseが入っているからこれだけでOK
        print(f'繰り返し前です。')
        print(f" 左端は{left}です。右端は{right}です。")
    #右端の値が左端の値以上になるまで繰り返す
    while right >= left:
        count += 1#繰り返しごとに1を足し合わせる。
        #leftとrightの真ん中の値を取得
        mid = left + (right - left) // 2#小数点切り捨て　年齢で小数は考えたくないよね
        #もしageがmidと同じならそれが答えなので繰り返しをやめる
        if age == mid:
            break
        #もしageがmid未満なら右端(right)をmid - 1にする (midは求める値の範囲に入らない！)
        elif age < mid:
            right = mid -1
        #もしageがmidより大きいなら左端(left)をmid + 1にする　(midは求める値の範囲に入らない！)
        elif age > mid:
            left = mid + 1

        #もし処理状態の表示が有なら表示する
        if display:
            print(f'現在{count}回目の繰り返しです。')
            print(f" 左端は{left}です。右端は{right}です。真ん中は{mid}です。")
    #最終的にmidの値が当てる年齢になるのでmidを返す
    return mid

```
いかがでしょうか？初めのコードよりもコードがすっきりしたことに加え、関数化することで、再度この処理を容易に実行でき、left、right、age、displayの調整を簡単にすることができるようになりました。

早速作成した関数を使っていくつかコードを記述してみましょう!!

## 関数の利用
作成した関数を使ってみましょう。

まず初めに当てる年齢をfor分を使って変化させてみましょう。

```python
#iを30から40まで変化させて繰り返す
for i in range(30,40+1):
    answer = guess_age(left = 0,right = 100,age = i,display=False)#年齢の範囲は0歳から100歳まで、当てる年齢はi歳、画面に処理状況は表示しない
    print(f'あなたの年齢は{answer}歳です！！')

```
```python
出力
あなたの年齢は30歳です！！
あなたの年齢は31歳です！！
あなたの年齢は32歳です！！
あなたの年齢は33歳です！！
あなたの年齢は34歳です！！
あなたの年齢は35歳です！！
あなたの年齢は36歳です！！
あなたの年齢は37歳です！！
あなたの年齢は38歳です！！
あなたの年齢は39歳です！！
あなたの年齢は40歳です！！
```

次に引数を調整してみましょう。

```python
print(guess_age(left = 0,right = 100,age = 55,display=False))#年齢の範囲は0歳から100歳まで、当てる年齢は55歳、画面に処理状況を表示
```
```python
出力
繰り返し前です。
 左端は0です。右端は100です。
現在1回目の繰り返しです。
 左端は51です。右端は100です。真ん中は50です。
現在2回目の繰り返しです。
 左端は51です。右端は74です。真ん中は75です。
現在3回目の繰り返しです。
 左端は51です。右端は61です。真ん中は62です。
現在4回目の繰り返しです。
 左端は51です。右端は55です。真ん中は56です。
現在5回目の繰り返しです。
 左端は54です。右端は55です。真ん中は53です。
現在6回目の繰り返しです。
 左端は55です。右端は55です。真ん中は54です。
55
```

このようにプログラムを関数化することで、プログラムの再利用のしやすさ、プログラムの管理のしやすさ、理解しやすさを向上させることができます！
